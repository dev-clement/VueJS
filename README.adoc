= VueJS learning

:toc:
:sectnums:
:imagesdir: ./images/

== Introduction
In this README, there will be some information regarding the VueJS framework, however it won't show everything, everything won't be covered. Hence, it might be also a good idea to look over all the project that are present on this repository.

== What is vuejs
VueJS is a javascript framework that has been around from 2014, millions of developpers has choosen VueJS because it got everything you need to create and scale performance product. Whether you're a startup, a huge company, VueJS have everything you need hunder the hood.

VueJS has its reactivity system that is the declarative rendering, that means Vue will does a lot of heavy lifting for you. Because VueJS is a progressive framework, you can start by the default library and add some other tool that is part of Vue ecosystem. For such things like:

. Static Site Generation
. Server Side Rendering
. Build Toolchain
. Testing Utils
. IDE Support
. State Management
. Vue Router

Moreover, VueJS has great capability by emdedding the TypeScript into it, making Vue fitting your workflow. It's finetune design, preventing your component for overrendering, keep your app performance as it scales.

Also, instead of optimize your code, vue takes your code and optimized it for you, as it compile and stay fine.

== VueJS State
Technically, VueJS's components already "manages" its own reactive states. For instance, if you look at a simple example such as a counter component:

```vuejs
<script setup>
import { ref } from 'vue'

// state
const count = ref(0)

// actions
function increment() {
  count.value++
}
</script>

<!-- view -->
<template>{{ count }}</template>
```
This component that is self-contained unit with the following parts inside:

* The state source of truth that drives your app
* The *View* that is a declarative mapping of the state
* The _action_, the possible ways the state could change in reaction to user inputs from the view.

image::state-flow.png[]

*However*, the simplicity starts to break down when we have several components that share a common state:

. Multiple views may depend on the same piece of state
. Actions from different views may need to mutate the same piece of state

=== Case one

For Multipe views that may depends on the same piece of state, a possible workaround is by *litfting* the shared state up to a common ancestor component, and then pass it down as a props. However this quickly gets tedious in component trees with deep hierarchies, leading to another problem known as _Prop drilling_

==== Prop drilling
Usually, when  we need to pass data from the parent to a child component, we use link:https://vuejs.org/guide/components/props[Props]. 

However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:

image::prop-drilling.png[]

Notice although the `<Footer>` component may not care about these props at all, it still needs to declare and pass them along just so `<DeepChild>` can access them. If there is a longer parent chain, more components would be affected along the way. This fact is also called _Props drilling and definitely isn't fun to deal with.

We can solve props drilling with _provide_ and _inject_. A parent component can serve as a dependency provider for all its descendants. Any component in the descendant tree, regardless of how deep it is, can *inject* depedencies provided by components up in its parent chain.

image::provide-inject.png[]

=== Case two

For case two, we often find ourselves resorting to solutions such as reaching for direct parent / child instances via template ref, or typing to mutate and synchronize multipe copies of the state via emitted events. Both of these patterns are brittle and quicky lead to unmaintainable code.

== State using Composable
In the context of Vue applications, a "composable" is a function that leverages Vue's Composition API to encapsulate and reuse *stateful* *logic*.

When building frontend applications, we often need to reuse ogic for common tasks. For example we may need to format dates in many places, so we extract a reusable function immediately and returns the expected output. This formatter function encapsulates *stateless logic.* It takes some input and immediately returns expected output. Then are many libraries out there for reusing stateless logic - for example _lodash_ and _date-fns_, whhich you may have heard of.

By contrast, stateful logic involves managing state that changes over time. A simple example would be tracking the current position of the mouse on a page. In real-world scenarios, it could also be more complex logic such as touch gestures or connection status to a database.

=== State using Pinia
While our hand-rolled solution state-management will suffice for simple scenario, there are many more things to consider in a large-scale production application.

* Stronger conversion for team collaboration
* Integrating with a Vue DevTools, including timeline, in-componen inspection, and time-travel debugging
* Hot module Replacement
* Server-side rendering support

Pinia is a state-management library that implements all of the above. It is maintained by the Vue core team, and works with both Vue 2 and Vue 3.

Existing users may be familiar with Vuex, the previous official state management library for Vue. With Pinia serving the same role in the ecosystem, Vuex is now in maintenance mode. It still works, but will no longer receive new features. It is recommended to use Pinia for new applications.

Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.

Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.

==== Why should I use Pinia ?
Pinia is a store library for Vue, it allows you to share a state across components/pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple export const state = reactive({}). This is true for single page applications but exposes your application to security vulnerabilities if it is server side render. But even in small single page applications, you get a lot from using Pinia.